/**
 * Mock API Service Layer
 * 
 * This module simulates API calls with artificial 500ms delay to mimic network latency.
 * In a real application, these functions would make actual HTTP requests to a backend.
 * 
 * EXTENSIBILITY GUIDE:
 * To connect to a real API:
 * 1. Replace the simulated delay with actual fetch() calls
 * 2. Update the base URL and endpoint paths
 * 3. Add authentication headers if needed (Authorization, etc.)
 * 4. Update error handling to match your backend response format
 * 
 * All functions follow the same pattern:
 * 1. Simulate network latency with delay
 * 2. Handle errors gracefully
 * 3. Return consistent ApiResponse format
 */

import { User, UserFormData, ApiResponse } from '@/src/types/user';

/**
 * Simulates network latency
 * Remove or adjust this in production when calling real APIs
 *
 * @param ms - Milliseconds to delay
 */
const delay = (ms: number): Promise<void> => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

/**
 * In-memory data store for users
 * In production, this would be replaced with backend database calls
 */
const defaultUsers: User[] = [
  {
    id: '1',
    firstName: 'Alice',
    lastName: 'Johnson',
    email: 'alice@example.com',
    phone: '(555) 123-4567',
    createdAt: new Date('2024-01-15').toISOString(),
  },
  {
    id: '2',
    firstName: 'Bob',
    lastName: 'Smith',
    email: 'bob@example.com',
    phone: '(555) 234-5678',
    createdAt: new Date('2024-02-20').toISOString(),
  },
  {
    id: '3',
    firstName: 'Carol',
    lastName: 'Williams',
    email: 'carol@example.com',
    phone: '(555) 345-6789',
    createdAt: new Date('2024-03-10').toISOString(),
  },
];

let usersDatabase: User[] = [...defaultUsers];

/**
 * Generates a unique ID for new users
 * In production, this would be generated by the backend
 *
 * @returns A unique string ID
 */
const generateId = (): string => {
  return Date.now().toString();
};

/**
 * Fetches all users
 * Simulates GET /api/users request
 *
 * @returns Promise resolving to list of all users
 */
export const getUsers = async (): Promise<ApiResponse<User[]>> => {
  try {
    await delay(500); // Simulate network latency
    return {
      success: true,
      data: [...usersDatabase],
    };
  } catch (error) {
    return {
      success: false,
      error: 'Failed to fetch users. Please try again.',
    };
  }
};

/**
 * Creates a new user
 * Simulates POST /api/users request
 *
 * @param userData - The user data to create
 * @returns Promise resolving to the created user with ID and timestamp
 */
export const createUser = async (
  userData: UserFormData
): Promise<ApiResponse<User>> => {
  try {
    await delay(500); // Simulate network latency

    // Validation would be done on backend in production
    if (!userData.firstName || !userData.lastName || !userData.email || !userData.phone) {
      return {
        success: false,
        error: 'All fields are required',
      };
    }

    // Check for duplicate email (simple validation)
    if (usersDatabase.some((user) => user.email === userData.email)) {
      return {
        success: false,
        error: 'User with this email already exists',
      };
    }

    const newUser: User = {
      id: generateId(),
      ...userData,
      createdAt: new Date().toISOString(),
    };

    usersDatabase.push(newUser);

    return {
      success: true,
      data: newUser,
    };
  } catch (error) {
    return {
      success: false,
      error: 'Failed to create user. Please try again.',
    };
  }
};

/**
 * Updates an existing user
 * Simulates PUT /api/users/:id request
 *
 * @param id - The user ID to update
 * @param userData - The updated user data
 * @returns Promise resolving to the updated user
 */
export const updateUser = async (
  id: string,
  userData: UserFormData
): Promise<ApiResponse<User>> => {
  try {
    await delay(500); // Simulate network latency

    const userIndex = usersDatabase.findIndex((user) => user.id === id);

    if (userIndex === -1) {
      return {
        success: false,
        error: 'User not found',
      };
    }

    // Check if email is taken by another user
    if (usersDatabase.some((user) => user.email === userData.email && user.id !== id)) {
      return {
        success: false,
        error: 'Email is already in use by another user',
      };
    }

    const updatedUser: User = {
      ...usersDatabase[userIndex],
      ...userData,
    };

    usersDatabase[userIndex] = updatedUser;

    return {
      success: true,
      data: updatedUser,
    };
  } catch (error) {
    return {
      success: false,
      error: 'Failed to update user. Please try again.',
    };
  }
};

/**
 * Deletes a user
 * Simulates DELETE /api/users/:id request
 *
 * @param id - The user ID to delete
 * @returns Promise resolving with success status
 */
export const deleteUser = async (id: string): Promise<ApiResponse<void>> => {
  try {
    await delay(500); // Simulate network latency

    const userIndex = usersDatabase.findIndex((user) => user.id === id);

    if (userIndex === -1) {
      return {
        success: false,
        error: 'User not found',
      };
    }

    usersDatabase.splice(userIndex, 1);

    return {
      success: true,
    };
  } catch (error) {
    return {
      success: false,
      error: 'Failed to delete user. Please try again.',
    };
  }
};

/**
 * Gets user count
 * Useful for displaying statistics in the UI
 *
 * @returns Promise resolving to the number of users
 */
export const getUserCount = async (): Promise<number> => {
  await delay(200);
  return usersDatabase.length;
};

/**
 * Testing utility to reset or override the in-memory database
 * Not used in production code, but exported for Jest setup
 */
export const __resetUsersForTest = (users?: User[]): void => {
  usersDatabase = users ? [...users] : [...defaultUsers];
};
